---
title: "TP1_SEM"
output:
  pdf_document:
    latex_engine: xelatex
date: "2025-09-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Partie 1 QUIZ

\textbf{Question 1 :} 5. Aucune de ces réponses.      

Le fichier est séparé par tabulations (sep = '\textbackslash t'), a un en-tête (header = TRUE) et le séparateur décimal est la virgule dec = ','. La commande correcte en R est par exemple : read.table("data", header = TRUE, sep = "\textbackslash t", dec = ","), la réponse 3 est la plus proche mais oublie dec = ","

\vspace{0.5em}

\textbf{Question 2} : 2. df_pats[df_pats$BP>17.5, c("gender", "Temp")]

La condition sur les lignes est df_pats$BP > 17.5. En seconde position on fournit les colonnes dans l’ordre voulu : c("gender","Temp").

\vspace{0.5em}

\textbf{Question 3.} Réponse : 1. Corrélation positive forte.  

Dans la figure A, quand $X$ augmente, $Y$ augmente aussi (nuage de points ascendant).

\vspace{0.5em}

\textbf{Question 4.} Réponse : 3. Transformer un revenu en classes produit une variable ordinale.  

Les autres propositions décrivent mal le type d'échelle. Par exemple pour la 1 si les données sont pris en celsius en convertissant en kelvin, on n'a pas le même ratio, pour la réponse 2 elle est mesurée en échelle ordinale. Pour la 4 (sauf exeption) il n'y a aucun sens a faire une moyenne et si on le faisait on obtiendra par exemple 2,3 qui n'a aucun sens par rapport à notre variable.

\vspace{0.5em}

\textbf{Question 5.} Réponse : 4. 100% des clients sont moyennement satisfaits.

Moyenne = 1 et écart-type = 0 signifie que toutes les réponses valent 1 (exeption de la Question 4).

\vspace{0.5em}

\textbf{Question 6.} Réponse : 4. 25% des fleurs ont une largeur de sépale $>$ 3,3 et 25% $\leq 2,8$.  

Le boxplot montre la médiane autour de 3 (et non la moyenne, aucune information sur la moyenne), la boîte (Q1–Q3) environ [2.8, 3.3]; il y a des points isolés au-dessus et en dessous. L’option 4 décrit correctement les quartiles et car Q1 ≈ 2.8 et Q3 ≈ 3.3. Les autres affirmations sont fausses.

\vspace{0.5em}

\textbf{Question 7.} Réponse : 2. 44,68% des hommes sont fumeurs.  

Taux des hommes fumeurs : $21/47 \approx 44,68\%$. Taux d'hommes dans l'échantillion : $47%$ Taux des femmes fumeurs : $13/40 = 32,5%$.

\vspace{0.5em}

\textbf{Question 8.} Réponse : 4. Skewness positive $\Rightarrow$ mode $<$ moyenne. 

Dans une distribution asymétrique à droite : mode $<$ médiane $<$ moyenne.

\vspace{0.5em}

\textbf{Question 9.} Réponse : 1. La valeur moyenne est 6,10.  

La somme est 61, divisée par 10 observations = 6,1. Médiane = 4, mode = 3.

\vspace{0.5em}

\textbf{Question 10.} Réponse : le code calcule la \textbf{médiane}.  

Si $n$ est pair, on prend la moyenne des deux valeurs centrales ; sinon, on prend l’élément du milieu.




## Partie 2 Initiation à la language R


```{r Exercice 1}
#Exercice 1
a=c(1,2,3)
b=c(4,5,6)
c=c(7,8,9)
a
b
c
mat=cbind(a,b,c)
mat
```

```{r exercice 2}
#Exercice 2
table0 = read.table("~/Table0.txt")
table0
#a) Changement du nom des colonnes en Nom, Age, Taille, Poids et Sexe
colnames(table0) <- c("Nom", "Age", "Taille", "Poids", "Sexe")
#b) Changement du nom des lignes par les noms puis supprimer la colonne Nom
rownames(table0) <- table0$Nom
table0$Nom = NULL
table0
```

```{r exercice 3}
#Exercice 3
table1 = read.table("~/Table1.txt")
table1
#a) Il contient 8 lignes et 5 colonnes
#b) Changement du tableau pour avoir le même tableau que Exercice 2 b) (sauf ici nom des colonnes en anglais)
table1 =read.table("~/Table1.txt", header = TRUE, stringsAsFactors = FALSE)
rownames(table1) <- table1$Name
table1$Name = NULL
table1
```

```{r exercice 4}
#Exercice 4
df <- read.csv("~/Cereals.csv", stringsAsFactors = FALSE)
head(df)
str(df)
#Nous avons un tableau nutritionnel décrivant 77 céréales différents par rapport 13 variables comme le nom du céréale et fournisseur (variables qualitatives) ou bien la quantité de calorie et sucre (variables quantitatives).
#a) Ajouter une nouvelle variable "totalcarb" = carbo + sugars
df$totalcarb <- df$carbo + df$sugars
#b) Nombre de céréales "hot"
sum(df$Cold.or.Hot == "H")

#c) Nombre de fournisseurs uniques
length(unique(df$Supplier))

#d) Sous-ensemble uniquement fournisseur "K" (Kellogg's)
df_K <- subset(df, Supplier == "K")

#e) Sous-ensemble : moins de 80 calories ET plus de 20 vitamines
df_calvi <- subset(df, calories < 80 & vitamins > 20)

#f) Sous-ensemble : au moins 1 sucre en ne gardant que "Cereal.name", "calories", "vitamins"
df_sugar <- subset(df, sugars >= 1, select = c(Cereal.name, calories, vitamins))
head(df_sugar)

#g) Sauvegarder un sous-ensemble en CSV (df_sugar)
write.csv(df_sugar, "Cereals_sugar.csv", row.names = FALSE)

#h) Renommer la colonne "Supplier" en "Producteur"
names(df)[names(df) == "Supplier"] <- "Producteur"

```

```{r exercice 5}
#Exercice 5
data("islands")
# Nombre total d'observations
length(islands)

# Description jeu  de données :
# 'islands' est un vecteur nommé : noms = îles/continents, valeurs = superficie (en milliers de miles²)
head(islands)

# Mesures de tendance centrale
mean(islands)     # Moyenne
median(islands)   # Médiane

# Range (minimum et maximum)
range(islands)                         # min et max
islands[which.max(islands)]            # plus grande île
islands[which.min(islands)]            # plus petite île

# Mesures de dispersion
sd(islands)              # Écart-type
quantile(islands, probs = c(0, 0.25, 0.5, 0.75, 1))     # 0%, 25%, 50%, 75%, 100%
quantile(islands, probs = c(0.005, 0.95))               # 0.5% et 95%

# Intervalle interquartile
IQR(islands)             #Quantile(0,75) - Quantile(0,25)

# Histogramme
# A. Fréquence
hist(islands, main="Histogramme des îles (fréquence)", xlab="Taille (en milliers de miles²)", col="lightblue")

# B. Proportion
hist(islands, main="Histogramme des îles (proportion)", xlab="Taille (en milliers de miles²)", col="lightgreen", freq = FALSE)

# Diagrammes en boîte
# C. Avec valeurs aberrantes
boxplot(islands, main="Boxplot des îles (avec points extrêmes/isolés)", col="orange")

# D. Sans valeurs aberrantes
boxplot(islands, outline=FALSE, main="Boxplot des îles (sans points extrêmes/isolés)", col="pink")

```

```{r exercice 6}
#Exercice 6
sales = read.csv("~/yearly_sales.csv", stringsAsFactors = FALSE)

# Créer la nouvelle variable
sales$spender <- cut(sales$sales_total, breaks = c(-Inf, 100, 500, Inf), labels = c("small", "medium", "big"), right = FALSE, ordered_result = TRUE)

# Vérifier le résultat
head(sales)
str(sales)

```